// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==========================================
// User Management
// ==========================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  username      String    @unique
  name          String?
  password      String    // Hashed password
  image         String?
  bio           String?
  
  // Gaming Details
  gamerTag      String?
  discordId     String?
  
  // User Role
  role          UserRole  @default(PLAYER)
  
  // Timestamps
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  emailVerified DateTime?
  
  // Relations
  registrations EventRegistration[]
  teamMemberships TeamMember[]
  createdTeams  Team[]              @relation("TeamCreator")
  createdEvents Event[]             @relation("EventCreator")
  seatReservations SeatReservation[]
  
  @@map("users")
}

enum UserRole {
  PLAYER
  ADMIN
  ORGANIZER
}

// ==========================================
// Event Management
// ==========================================

model Event {
  id              String   @id @default(cuid())
  name            String
  description     String?  @db.Text
  game            String   // e.g., "Apex Legends", "Valorant"
  
  // Event Details
  startDate       DateTime
  endDate         DateTime?
  registrationStart DateTime
  registrationEnd DateTime
  
  // Capacity & Rules
  maxParticipants Int
  teamSize        Int      @default(1) // 1 for solo, 2+ for teams
  status          EventStatus @default(DRAFT)
  
  // Venue
  venue           String?
  venueAddress    String?
  isOnline        Boolean  @default(false)
  
  // Entry
  entryFee        Float    @default(0)
  prizePool       Float?
  
  // Images
  bannerImage     String?
  thumbnailImage  String?
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  creatorId       String
  creator         User     @relation("EventCreator", fields: [creatorId], references: [id])
  
  registrations   EventRegistration[]
  seats           Seat[]
  brackets        Bracket[]
  
  @@map("events")
}

enum EventStatus {
  DRAFT
  PUBLISHED
  REGISTRATION_OPEN
  REGISTRATION_CLOSED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

// ==========================================
// Registration Management
// ==========================================

model EventRegistration {
  id              String   @id @default(cuid())
  
  // Registration Details
  status          RegistrationStatus @default(PENDING)
  checkInStatus   CheckInStatus      @default(NOT_CHECKED_IN)
  
  // Team Info
  teamId          String?
  team            Team?    @relation(fields: [teamId], references: [id])
  
  // Payment
  paymentStatus   PaymentStatus @default(UNPAID)
  paymentAmount   Float?
  
  // Timestamps
  registeredAt    DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  eventId         String
  event           Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([eventId, userId])
  @@map("event_registrations")
}

enum RegistrationStatus {
  PENDING
  APPROVED
  REJECTED
  WAITLIST
  CANCELLED
}

enum CheckInStatus {
  NOT_CHECKED_IN
  CHECKED_IN
  NO_SHOW
}

enum PaymentStatus {
  UNPAID
  PENDING
  PAID
  REFUNDED
}

// ==========================================
// Team Management
// ==========================================

model Team {
  id              String   @id @default(cuid())
  name            String
  tag             String?  // Team tag/abbreviation
  description     String?
  logo            String?
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  creatorId       String
  creator         User     @relation("TeamCreator", fields: [creatorId], references: [id])
  
  members         TeamMember[]
  registrations   EventRegistration[]
  
  @@map("teams")
}

model TeamMember {
  id              String   @id @default(cuid())
  role            TeamMemberRole @default(MEMBER)
  
  // Timestamps
  joinedAt        DateTime @default(now())
  
  // Relations
  teamId          String
  team            Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([teamId, userId])
  @@map("team_members")
}

enum TeamMemberRole {
  CAPTAIN
  CO_CAPTAIN
  MEMBER
}

// ==========================================
// Seat Management
// ==========================================

model Seat {
  id              String   @id @default(cuid())
  
  // Seat Identification
  row             String   // e.g., "A", "B", "C"
  number          Int      // Seat number in row
  label           String   // Display label e.g., "A1", "B5"
  
  // Seat Type
  type            SeatType @default(STANDARD)
  
  // Position (for visual layout)
  positionX       Float?   // X coordinate for seat map
  positionY       Float?   // Y coordinate for seat map
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  eventId         String
  event           Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  reservations    SeatReservation[]
  
  @@unique([eventId, row, number])
  @@map("seats")
}

enum SeatType {
  STANDARD
  VIP
  WHEELCHAIR_ACCESSIBLE
  RESERVED
}

model SeatReservation {
  id              String   @id @default(cuid())
  
  // Reservation Status
  status          ReservationStatus @default(RESERVED)
  
  // Timestamps
  reservedAt      DateTime @default(now())
  updatedAt       DateTime @updatedAt
  expiresAt       DateTime? // For temporary holds
  
  // Relations
  seatId          String
  seat            Seat     @relation(fields: [seatId], references: [id], onDelete: Cascade)
  
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([seatId])
  @@map("seat_reservations")
}

enum ReservationStatus {
  RESERVED
  CONFIRMED
  CANCELLED
  EXPIRED
}

// ==========================================
// Bracket Management
// ==========================================

model Bracket {
  id              String   @id @default(cuid())
  
  // Bracket Configuration
  name            String
  type            BracketType @default(SINGLE_ELIMINATION)
  status          BracketStatus @default(NOT_STARTED)
  
  // Bracket Settings
  roundCount      Int      // Total number of rounds
  currentRound    Int      @default(1)
  thirdPlaceMatch Boolean  @default(false) // Include 3rd place match
  
  // Metadata
  startedAt       DateTime?
  completedAt     DateTime?
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  eventId         String
  event           Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  matches         BracketMatch[]
  participants    BracketParticipant[]
  
  @@map("brackets")
}

enum BracketType {
  SINGLE_ELIMINATION
  DOUBLE_ELIMINATION
  ROUND_ROBIN
  SWISS
}

enum BracketStatus {
  NOT_STARTED
  IN_PROGRESS
  COMPLETED
}

model BracketMatch {
  id              String   @id @default(cuid())
  
  // Match Identification
  round           Int      // Which round (1, 2, 3, etc.)
  matchNumber     Int      // Match number within round
  position        Int      // Position in bracket (for ordering)
  
  // Match Type
  isWinnersBracket Boolean @default(true) // For double elimination
  isThirdPlace    Boolean @default(false)
  
  // Match State
  status          MatchStatus @default(PENDING)
  
  // Participants (can be null if waiting for previous matches)
  participant1Id  String?
  participant1    BracketParticipant? @relation("Participant1", fields: [participant1Id], references: [id])
  
  participant2Id  String?
  participant2    BracketParticipant? @relation("Participant2", fields: [participant2Id], references: [id])
  
  // Results
  winnerId        String?
  winner          BracketParticipant? @relation("Winner", fields: [winnerId], references: [id])
  
  score1          Int?     // Score for participant 1
  score2          Int?     // Score for participant 2
  
  // Next Match References
  nextMatchId     String?  // Winner goes to this match
  nextMatch       BracketMatch? @relation("NextMatch", fields: [nextMatchId], references: [id])
  previousMatches BracketMatch[] @relation("NextMatch")
  
  nextMatchLosersBracket String? // For double elimination losers
  
  // Schedule
  scheduledTime   DateTime?
  startedAt       DateTime?
  completedAt     DateTime?
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  bracketId       String
  bracket         Bracket  @relation(fields: [bracketId], references: [id], onDelete: Cascade)
  
  @@map("bracket_matches")
}

enum MatchStatus {
  PENDING
  READY
  IN_PROGRESS
  COMPLETED
  BYE
}

model BracketParticipant {
  id              String   @id @default(cuid())
  
  // Participant Details
  seed            Int      // Seeding position
  name            String   // Display name (username or team name)
  
  // Participant Type
  isTeam          Boolean  @default(false)
  
  // User or Team Reference
  userId          String?
  teamId          String?
  
  // Stats
  wins            Int      @default(0)
  losses          Int      @default(0)
  finalPlacement  Int?     // Final ranking in tournament
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  bracketId       String
  bracket         Bracket  @relation(fields: [bracketId], references: [id], onDelete: Cascade)
  
  matchesAsParticipant1 BracketMatch[] @relation("Participant1")
  matchesAsParticipant2 BracketMatch[] @relation("Participant2")
  matchesWon            BracketMatch[] @relation("Winner")
  
  @@unique([bracketId, seed])
  @@map("bracket_participants")
}
